'''
[1이 될 때까지]
- 어떠한 수 N이 1이될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행한다.
    1. N -= 1
    2. N /= K
- 구해야하는 것 : N이 1이 될 때까지 1,2 과정을 수행해야 하는 최소횟수.
- 아이디어 : 
    - 새로운 방식 생각해보고 싶음.. 마침 지난주 dp 문제에서 비슷한 유형본 듯
    - dp 테이블을 활용해서 기존에 연산이 끝난 것의 횟수를 계속 갱신한다면?? => 효율성 증가시킬 수 있지 않나??
    - 점화식은? => dp[i] = min(1번 연산 횟수, 2번 연산 횟수)
'''
INF = int(1e9)

#입력
n, k = map(int, input().split())

#풀이
dp = [INF] * (n+1) #i(인덱스)값이 되기 위한 최소연산횟수 저장

for i in range(1,n+1):
    dp[i] = i-1 #1번 연산은 어차피 모두 다 가능(일단 함) => 연산횟수는 해당 숫자 - 1(EX. 2는 1번 연산은 1번 수행, 99는 98번 수행해야 1을 만들 수 있음)
    if i % k == 0: #2번 연산은 해당 숫자가 k로 나누어 떨어져야지만 가능
        dp[i] = min(dp[i], dp[i//k]+1) #dp[i//k] => 만약 숫자가 k로 나누어 떨어진다면, 그말은 그 숫자를 k로 나눈 몫이 바로 이전 연산했던 숫자라는 것 => 그러니까 해당 인덱스의 연산횟수 + 1이 결과가 됨

#출력
result = dp[n] #이미 dp테이블에는 각 인덱스만큼의 숫자에 대한 최소연산횟수가 저장됨
print(result)